"""
PBR Texture Set Importer for Blender
====================================

A Blender addon that automatically imports PBR texture sets generated by the
tessellating-pbr-generator, creating properly configured Principled BSDF materials.

Author: Claude (Anthropic)
Version: 1.0.0
Blender Version: 3.0+
"""

bl_info = {
    "name": "PBR Texture Set Importer",
    "author": "Claude (Anthropic)",
    "version": (1, 0, 0),
    "blender": (3, 0, 0),
    "location": "File > Import > PBR Texture Set",
    "description": "Import PBR texture sets with automatic material setup",
    "warning": "",
    "doc_url": "",
    "category": "Import-Export",
}

import bpy
import os
from pathlib import Path
from bpy.props import StringProperty, BoolProperty, FloatProperty
from bpy_extras.io_utils import ImportHelper


class PBR_OT_import_texture_set(bpy.types.Operator, ImportHelper):
    """Import a PBR texture set and create a material"""
    bl_idname = "import_texture.pbr_set"
    bl_label = "Import PBR Texture Set"
    bl_options = {'REGISTER', 'UNDO'}
    
    # File browser filter
    filter_folder: BoolProperty(default=True, options={'HIDDEN'})
    
    # Import options
    create_new_material: BoolProperty(
        name="Create New Material",
        description="Create a new material even if one with the same name exists",
        default=True
    )
    
    apply_to_selected: BoolProperty(
        name="Apply to Selected Objects",
        description="Apply the material to selected objects",
        default=True
    )
    
    displacement_scale: FloatProperty(
        name="Displacement Scale",
        description="Scale factor for displacement/height map",
        default=0.1,
        min=0.0,
        max=1.0
    )
    
    ao_mix_factor: FloatProperty(
        name="AO Mix Factor",
        description="How much to mix ambient occlusion with diffuse",
        default=0.5,
        min=0.0,
        max=1.0
    )
    
    def execute(self, context):
        """Execute the import operation"""
        # Get the selected folder path
        folder_path = Path(self.filepath)
        if not folder_path.is_dir():
            folder_path = folder_path.parent
            
        # Find all texture files in the folder
        texture_files = self.find_texture_files(folder_path)
        
        if not texture_files:
            self.report({'ERROR'}, f"No texture files found in {folder_path}")
            return {'CANCELLED'}
        
        # Extract the base name from the textures
        base_name = self.get_base_name(texture_files)
        
        # Create the material
        material = self.create_material(base_name, texture_files, folder_path)
        
        if not material:
            self.report({'ERROR'}, "Failed to create material")
            return {'CANCELLED'}
        
        # Apply to selected objects if requested
        if self.apply_to_selected:
            self.apply_material_to_selected(material)
            
        self.report({'INFO'}, f"Successfully imported PBR set: {base_name}")
        return {'FINISHED'}
    
    def find_texture_files(self, folder_path):
        """Find all PBR texture files in the folder"""
        texture_types = {
            'diffuse': ['diffuse', 'albedo', 'color', 'basecolor'],
            'normal': ['normal', 'norm', 'nrm'],
            'roughness': ['roughness', 'rough', 'rgh'],
            'metallic': ['metallic', 'metal', 'met'],
            'height': ['height', 'displacement', 'disp', 'bump'],
            'ao': ['ao', 'ambient_occlusion', 'occlusion', 'occ']
        }
        
        found_textures = {}
        
        # Supported image extensions
        extensions = ['.png', '.jpg', '.jpeg', '.tif', '.tiff', '.exr']
        
        # Search for texture files
        for file_path in folder_path.iterdir():
            if file_path.is_file() and file_path.suffix.lower() in extensions:
                filename_lower = file_path.stem.lower()
                
                # Check each texture type
                for tex_type, keywords in texture_types.items():
                    for keyword in keywords:
                        if keyword in filename_lower:
                            found_textures[tex_type] = file_path
                            break
        
        return found_textures
    
    def get_base_name(self, texture_files):
        """Extract the base name from texture filenames"""
        if not texture_files:
            return "PBR_Material"
            
        # Get the first texture filename
        first_texture = next(iter(texture_files.values()))
        filename = first_texture.stem
        
        # Remove common texture type suffixes
        suffixes_to_remove = [
            '_diffuse', '_albedo', '_color', '_basecolor',
            '_normal', '_norm', '_nrm',
            '_roughness', '_rough', '_rgh',
            '_metallic', '_metal', '_met',
            '_height', '_displacement', '_disp', '_bump',
            '_ao', '_ambient_occlusion', '_occlusion', '_occ'
        ]
        
        base_name = filename.lower()
        for suffix in suffixes_to_remove:
            if base_name.endswith(suffix):
                base_name = filename[:-(len(suffix))]
                break
                
        # Also handle resolution suffixes like _1024x1024
        import re
        base_name = re.sub(r'_\d+x\d+$', '', base_name)
        
        return base_name
    
    def create_material(self, base_name, texture_files, folder_path):
        """Create a material with the PBR textures"""
        # Create or get material
        if self.create_new_material or base_name not in bpy.data.materials:
            material = bpy.data.materials.new(name=base_name)
        else:
            material = bpy.data.materials[base_name]
            
        material.use_nodes = True
        nodes = material.node_tree.nodes
        links = material.node_tree.links
        
        # Clear existing nodes
        nodes.clear()
        
        # Create Principled BSDF node
        principled = nodes.new(type='ShaderNodeBsdfPrincipled')
        principled.location = (0, 0)
        
        # Create output node
        output = nodes.new(type='ShaderNodeOutputMaterial')
        output.location = (300, 0)
        
        # Link Principled to Output
        links.new(principled.outputs['BSDF'], output.inputs['Surface'])
        
        # Track node positions for layout
        x_offset = -300
        y_offset = 0
        y_spacing = 300
        
        # Load and connect diffuse/albedo texture
        if 'diffuse' in texture_files:
            diffuse_node = self.create_texture_node(
                nodes, str(texture_files['diffuse']), 'diffuse', 'sRGB'
            )
            diffuse_node.location = (x_offset, y_offset)
            
            # Check if we need to mix with AO
            if 'ao' in texture_files and self.ao_mix_factor > 0:
                # Create AO texture node
                ao_node = self.create_texture_node(
                    nodes, str(texture_files['ao']), 'ao', 'Non-Color'
                )
                ao_node.location = (x_offset, y_offset - y_spacing)
                
                # Create mix node
                mix_node = nodes.new(type='ShaderNodeMixRGB')
                mix_node.blend_type = 'MULTIPLY'
                mix_node.inputs['Fac'].default_value = self.ao_mix_factor
                mix_node.location = (x_offset + 300, y_offset - y_spacing//2)
                
                # Connect nodes
                links.new(diffuse_node.outputs['Color'], mix_node.inputs['Color1'])
                links.new(ao_node.outputs['Color'], mix_node.inputs['Color2'])
                links.new(mix_node.outputs['Color'], principled.inputs['Base Color'])
            else:
                # Direct connection
                links.new(diffuse_node.outputs['Color'], principled.inputs['Base Color'])
            
            y_offset -= y_spacing
        
        # Load and connect normal map
        if 'normal' in texture_files:
            normal_tex = self.create_texture_node(
                nodes, str(texture_files['normal']), 'normal', 'Non-Color'
            )
            normal_tex.location = (x_offset, y_offset)
            
            # Create Normal Map node
            normal_map = nodes.new(type='ShaderNodeNormalMap')
            normal_map.location = (x_offset + 300, y_offset)
            
            # Connect nodes
            links.new(normal_tex.outputs['Color'], normal_map.inputs['Color'])
            links.new(normal_map.outputs['Normal'], principled.inputs['Normal'])
            
            y_offset -= y_spacing
        
        # Load and connect roughness map
        if 'roughness' in texture_files:
            roughness_node = self.create_texture_node(
                nodes, str(texture_files['roughness']), 'roughness', 'Non-Color'
            )
            roughness_node.location = (x_offset, y_offset)
            links.new(roughness_node.outputs['Color'], principled.inputs['Roughness'])
            y_offset -= y_spacing
        
        # Load and connect metallic map
        if 'metallic' in texture_files:
            metallic_node = self.create_texture_node(
                nodes, str(texture_files['metallic']), 'metallic', 'Non-Color'
            )
            metallic_node.location = (x_offset, y_offset)
            links.new(metallic_node.outputs['Color'], principled.inputs['Metallic'])
            y_offset -= y_spacing
        
        # Load and connect height/displacement map
        if 'height' in texture_files:
            height_node = self.create_texture_node(
                nodes, str(texture_files['height']), 'height', 'Non-Color'
            )
            height_node.location = (x_offset, y_offset)
            
            # Create Displacement node
            displacement = nodes.new(type='ShaderNodeDisplacement')
            displacement.inputs['Scale'].default_value = self.displacement_scale
            displacement.location = (0, -300)
            
            # Connect nodes
            links.new(height_node.outputs['Color'], displacement.inputs['Height'])
            links.new(displacement.outputs['Displacement'], output.inputs['Displacement'])
        
        return material
    
    def create_texture_node(self, nodes, filepath, name, color_space):
        """Create an image texture node"""
        # Load the image
        image = bpy.data.images.load(filepath)
        
        # Set color space
        image.colorspace_settings.name = color_space
        
        # Create texture node
        texture_node = nodes.new(type='ShaderNodeTexImage')
        texture_node.image = image
        texture_node.name = f"TEX_{name}"
        texture_node.label = name.title()
        
        return texture_node
    
    def apply_material_to_selected(self, material):
        """Apply the material to all selected objects"""
        for obj in bpy.context.selected_objects:
            if obj.type == 'MESH':
                # Assign material to object
                if obj.data.materials:
                    # Replace first material slot
                    obj.data.materials[0] = material
                else:
                    # Add new material slot
                    obj.data.materials.append(material)


def menu_func_import(self, context):
    """Add the import option to the File > Import menu"""
    self.layout.operator(PBR_OT_import_texture_set.bl_idname, 
                        text="PBR Texture Set")


def register():
    """Register the addon"""
    bpy.utils.register_class(PBR_OT_import_texture_set)
    bpy.types.TOPBAR_MT_file_import.append(menu_func_import)


def unregister():
    """Unregister the addon"""
    bpy.utils.unregister_class(PBR_OT_import_texture_set)
    bpy.types.TOPBAR_MT_file_import.remove(menu_func_import)


if __name__ == "__main__":
    register()