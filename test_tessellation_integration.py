"""Integration test for tessellation with the PBR generator."""

import os
import sys
from PIL import Image
import numpy as np

# Add modules to path directly
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src', 'modules'))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

from tessellation import TessellationModule


def test_with_generated_textures():
    """Test tessellation with textures generated by the PBR system."""
    print("Testing tessellation integration with PBR textures...")
    
    tess = TessellationModule()
    
    # List of textures to test
    texture_files = [
        ("stone_diffuse_1024x1024.png", "Diffuse"),
        ("stone_height_1024x1024.png", "Height"),
        ("stone_roughness_1024x1024.png", "Roughness"),
        ("stone_metallic_1024x1024.png", "Metallic"),
        ("stone_ao_1024x1024.png", "Ambient Occlusion")
    ]
    
    results = []
    
    for filename, texture_type in texture_files:
        filepath = os.path.join("output", filename)
        if not os.path.exists(filepath):
            print(f"  ‚ö†Ô∏è  {texture_type} texture not found: {filepath}")
            continue
        
        print(f"\n  Testing {texture_type} texture...")
        
        # Load and resize for faster testing
        original = Image.open(filepath)
        test_size = 512
        original = original.resize((test_size, test_size), Image.Resampling.LANCZOS)
        
        # Test different methods
        methods = ['offset', 'mirror', 'frequency']
        best_method = None
        best_diff = float('inf')
        
        for method in methods:
            try:
                seamless = tess.make_seamless(original, blend_mode=method)
                is_seamless, max_diff = tess.validate_tiling(seamless)
                
                print(f"    {method}: seamless={is_seamless}, max_diff={max_diff:.4f}")
                
                if max_diff < best_diff:
                    best_diff = max_diff
                    best_method = method
                
                # Save the best result
                if method == 'offset':  # Save offset as default
                    output_name = filename.replace('.png', '_seamless.png')
                    seamless.save(os.path.join("output", output_name))
                    
                    # Create tiled visualization
                    tiled = Image.new(original.mode, (test_size * 2, test_size * 2))
                    for y in range(2):
                        for x in range(2):
                            tiled.paste(seamless, (x * test_size, y * test_size))
                    
                    tiled_name = filename.replace('.png', '_seamless_tiled.png')
                    tiled.save(os.path.join("output", tiled_name))
                    
            except Exception as e:
                print(f"    {method}: ERROR - {str(e)}")
        
        results.append({
            'texture': texture_type,
            'best_method': best_method,
            'best_diff': best_diff,
            'is_seamless': best_diff < 0.1
        })
    
    # Print summary
    print("\nüìä Tessellation Results Summary:")
    print("-" * 60)
    print(f"{'Texture Type':<20} {'Best Method':<15} {'Max Diff':<10} {'Seamless':<10}")
    print("-" * 60)
    
    for result in results:
        status = "‚úÖ" if result['is_seamless'] else "‚ùå"
        print(f"{result['texture']:<20} {result['best_method']:<15} "
              f"{result['best_diff']:<10.4f} {status}")
    
    print("-" * 60)
    print(f"Success rate: {sum(r['is_seamless'] for r in results)}/{len(results)}")
    
    # Save configuration recommendation
    recommendations = {
        'default_method': 'offset',
        'texture_specific': {}
    }
    
    for result in results:
        if result['best_method'] != 'offset':
            recommendations['texture_specific'][result['texture'].lower()] = result['best_method']
    
    print("\nüìù Recommendations for config:")
    print(f"Default method: {recommendations['default_method']}")
    if recommendations['texture_specific']:
        print("Texture-specific overrides:")
        for tex, method in recommendations['texture_specific'].items():
            print(f"  - {tex}: {method}")


def test_base_class_integration():
    """Test that the base class make_seamless works correctly."""
    print("\n\nTesting base class integration...")
    
    from base import TextureGenerator
    from pbr_types.config import Config, MaterialProperties, TextureConfig, Resolution
    
    # Create a test config
    config = Config(
        material_properties=MaterialProperties(
            base_color=(128, 128, 128),
            roughness=0.5,
            metallic=0.0
        ),
        texture_config=TextureConfig(
            resolution=Resolution(width=256, height=256),
            seamless=True  # Enable seamless
        )
    )
    
    # Create a simple test generator
    class TestGenerator(TextureGenerator):
        @property
        def texture_type(self):
            from pbr_types.common import TextureType
            return TextureType.DIFFUSE
        
        def generate(self, input_data=None):
            # Create a simple pattern
            size = self.resolution.width
            arr = np.zeros((size, size, 3), dtype=np.uint8)
            
            # Add some features
            for i in range(0, size, 32):
                arr[i:i+16, :] = [255, 100, 0]
                arr[:, i:i+16] = [0, 100, 255]
            
            return Image.fromarray(arr, 'RGB')
    
    # Generate and make seamless
    generator = TestGenerator(config)
    texture = generator.generate()
    texture.save("output/test_base_class_original.png")
    
    seamless = generator.make_seamless(texture)
    seamless.save("output/test_base_class_seamless.png")
    
    # Validate
    tess = TessellationModule()
    is_seamless, max_diff = tess.validate_tiling(seamless)
    print(f"  Base class make_seamless: seamless={is_seamless}, max_diff={max_diff:.4f}")
    
    print("\n‚úÖ Integration tests complete!")


if __name__ == "__main__":
    test_with_generated_textures()
    test_base_class_integration()